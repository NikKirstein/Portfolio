from elasticsearch import Elasticsearch
import nltk
from nltk.sentiment import SentimentIntensityAnalyzer



def get_admin_ckeys():
    """
    Pulls a list of admins and their roles from a list.
    This list is generated by the Server. 
    I simply save a copy for usage.
    returns a dictionary of their name as a key, and their rank as a value
    """
    file_contents_list = []
    with open(r"admin_list.txt", "r") as f:
        for line in f:
            file_contents_list.append(line)

    admin_dict = {}
    for ckey_and_rank in file_contents_list:
        admin_dict[(ckey_and_rank.split(' ')[0])] = []
    # print(admin_dict)

    return admin_dict

def get_all_pms_from_es(es_input):
    """
    Takes an elasticsearch connector input, and uses the below query to filter out specific actions they took
    in order to just get ticket communication between admin and player.
    Returns a list of every single message every admin from the admin list sent to and from other people
    """
    
    search_query = {"query": { "bool": { "must": [], "filter": [ { "bool": { "filter":
    [ { "bool": { "should": [ { "match": { "logmessage": "PM" } } ], "minimum_should_match": 1 } },
    { "bool": { "must_not": { "multi_match": { "type": "best_fields", "query": "ASAY", "lenient": "true" } } } },
    { "bool": { "must_not": { "multi_match": { "type": "phrase", "query": "admin server ban", "lenient": "true" } } } },
    { "bool": { "must_not": { "multi_match": { "type": "phrase", "query": "External PM", "lenient": "true" } } } } ] } },
    { "bool": { "must_not": { "multi_match": {"type": "phrase", "query": "created a permanent server ban", "lenient": "true"}}}},
    { "bool": { "must_not": { "multi_match": {"type": "phrase", "query": "has created a temporary", "lenient": "true"}}}},
    { "bool": { "must_not": { "multi_match": {"type": "phrase", "query": "Ticket #", "lenient": "true"}}}},
    { "bool": { "must_not": { "multi_match": {"type": "phrase","query": "has created a note for","lenient": "true"}}}},
    { "bool": { "must_not": { "multi_match": {"type": "phrase", "query": "has edited a note", "lenient": "true"}}}},
    { "bool": { "must_not": { "multi_match": {"type": "phrase","query": "created a message for","lenient": "true"}}}},
    { "bool": { "must_not": { "multi_match": {"type": "phrase","query": "has edited a watchlist","lenient": "true"}}}},
    { "bool": { "must_not": { "multi_match": {"type": "phrase","query": "has created a watchlist","lenient": "true"}}}},
    { "bool": { "must_not": { "multi_match": {"type": "phrase","query": "has created a permanent role ban","lenient": "true"}}}},
    { "bool": { "must_not": { "multi_match": {"type": "phrase","query": "has created a temporary role ban","lenient": "true"}}}},
    { "bool": { "must_not": { "multi_match": {"type": "phrase","query": "has edited a message","lenient": "true"}}}},
    { "range": { "@timestamp": { "format": "strict_date_optional_time", "gte": "2020-12-28T08:00:00.000Z", "lte": "2022-01-01T08:00:00.000Z" } } },
    { "match_phrase": { "loglevel": "ADMINPRIVATE" } } ], "should": [], "must_not": [] } }}

    index_to_search = 'logs-*'

    def scroll(es, index, body, scroll, size, **kw):
        page = es.search(index=index, body=body, scroll=scroll, size=size, **kw)
        scroll_id = page['_scroll_id']
        hits = page['hits']['hits']
        while len(hits):
            yield hits
            page = es.scroll(scroll_id=scroll_id, scroll=scroll)
            scroll_id = page['_scroll_id']
            hits = page['hits']['hits']

    pm_list = []
    counter = 0
    for hits in scroll(es_input, index_to_search, search_query, '2m', 10000):
        counter += 10000
        print("Retrieved: ", str(counter))
        # if counter == 200000:
            # break
        for hit in hits:
            # print(hit)
            pm_list.append(hit['_source']['logmessage'])

    # print(len(pm_list))
    return pm_list

def write_pm_list_to_file(input_pm_list):
    """
    Writes all the ticket traffic from admins to other people to a file for easier usage.
    """
    with open(r"admin_pm_list.txt",
              "w", encoding="utf-8") as write_file:
        for pm in input_pm_list:
            write_file.write(pm + "\n")
    return

def filter_for_admin_sends(admin_dict, admin_pm_list):
    """
    Filters the list of ticket traffic to and from admins, to just from admins
    """
    counter = 0
    for pm in admin_pm_list:
        # PM: Unmaskedmasked/(Patrick Bateman)->Paxilmaniac/(Mothkaterina): yo, again, he charged me
        # print(pm)
        counter += 1
        # print(counter, pm)
        sending_ckey = ((pm.split('->')[0]).split('/')[0]).split("PM: ")[1].lower()
        # print(sending_ckey)
        if not "*null*" in pm and counter != 373512 and counter != 373568 and counter != 373580 and counter != 374606:
            just_message = pm.split('): ')[1].lower()
        # print(just_message)
        # print(list(admin_dict.keys()))
        # print("Filtering")
        # print(sending_ckey)
        if sending_ckey in list(admin_dict.keys()):
            # print("Firing")
            # print(sending_ckey in list(admin_dict.keys()))
            admin_dict[sending_ckey].append(just_message)

    return admin_dict

def normalize(admin_dict):
    """
    Normalizes the ticket traffic from admins by removing stop words
    """
    stopwords = nltk.corpus.stopwords.words("english")
    filtered_admin_dict = {}
    for admin, pm_list in admin_dict.items():
        # print(admin)
        # print(pm_list)
        filtered_admin_dict[admin] = []
        for indv_pm in pm_list:
            stripped_pm_list = []
            # print(indv_pm)
            indv_pm_list = indv_pm.split(' ')
            for word in indv_pm_list:
                # print(word)
                if word not in stopwords:
                    stripped_pm_list.append(word)
            stripped_pm = " ".join(stripped_pm_list)
            filtered_admin_dict[admin].append(stripped_pm)
    return filtered_admin_dict

def get_sentinment_score_dict(filtered_admin_dict):
    """
    Iterates through every ticket message send from an admin and assigns it a polarity score.
    Creates a new dictionary where the key is the admin, and the value is a list of the ticket message send polarity scores
    """
    admin_score_dict = {}
    sia = SentimentIntensityAnalyzer()
    for admin, stop_filtered_pm_list in filtered_admin_dict.items():
        admin_score_dict[admin] = []
        for indv_pm in stop_filtered_pm_list:
            if indv_pm != '':
                admin_score_dict[admin].append(sia.polarity_scores(indv_pm)['compound'])

    return admin_score_dict


def get_sentinment_summary_dict(score_dict):
    """
    Creates a summary dictionary per admin by averaging their message polarity scores.
    Final product is a dictionary of an admin names as keys, and a single averaged polarity value as a dictionary value.
    """
    def list_average(lst):
        return sum(lst) / len(lst)
    admin_sentinment_summary_dict = {}
    for admin, score_list in score_dict.items():
        if len(score_list) != 0:
            admin_sentinment_summary_dict[admin] = round(list_average(score_list), 3)
        else:
            admin_sentinment_summary_dict[admin] = 'N/A'

    return admin_sentinment_summary_dict


def create_summary(summary_dict):
    """
    Creates a quick list to print out of admin names and polarity averages
    """
    score_list = []
    for admin, score, in summary_dict.items():
        if score != "N/A":
            score_list.append(score)

    return score_list


def main():

    main_admin_dict = get_admin_ckeys()
    es = Elasticsearch(hosts=['10.0.1.15'])
    # print(es)
    all_admin_pms = get_all_pms_from_es(es)
    # write_pm_list_to_file(all_admin_pms)

    main_admin_dict = filter_for_admin_sends(main_admin_dict, all_admin_pms)
    main_filtered_admin_dict = normalize(main_admin_dict)
    # print(main_filtered_admin_dict)
    main_admin_score_dict = get_sentinment_score_dict(main_filtered_admin_dict)
    # print(main_admin_score_dict)
    score_summary_dict = get_sentinment_summary_dict(main_admin_score_dict)
    print(score_summary_dict)
    score_summary_list = create_summary(score_summary_dict)
    average_admin_score = sum(score_summary_list) / len(score_summary_list)
    print("Current /tg/ admin rating: ", str(average_admin_score))


main()